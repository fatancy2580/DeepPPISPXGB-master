import pickleimport numpy as npimport torchimport sysimport torch as timport torch.utils.data.sampler as samplerimport umapfrom torch.autograd import Variablefrom generator import data_generatorfrom models.deep_ppi import DeepPPIfrom utils.config import DefaultConfigimport matplotlib.pyplot as pltdef getnewmodel(models,seq, dssp, pssm, local_features):    models.eval()    shapes = seq.data.shape  # shape指的是序列的shape[32,1,500,20]    features = seq.view(shapes[0], shapes[1] * shapes[2] * shapes[3])    features = models.seq_layers(features)  # 将稀疏矩阵转为密集矩阵，放入全连接层    features = features.view(shapes[0], shapes[1], shapes[2], shapes[3])  # 再把序列的特征转为四维，因为pssm和dssp是四维的    features = t.cat((features, dssp, pssm), 3)  # 将序列和其他两个特征进行拼接    features = models.multi_CNN(features)  # 得到的特征是二维的    features = t.cat((features, local_features), 1)    return featuresdef trainfunction(train_loader,newmodel):    feature_batch = []    label_batch = []    for batch_idx, (seq_data, pssm_data, dssp_data, local_data, label) in enumerate(train_loader):        with torch.no_grad():            if torch.cuda.is_available():                seq_var = Variable(seq_data.cuda().float())                pssm_var = Variable(pssm_data.cuda().float())                dssp_var = Variable(dssp_data.cuda().float())                local_var = Variable(local_data.cuda().float())                target_var = Variable(label.cuda().float())            else:                seq_var = Variable(seq_data.float())                pssm_var = Variable(pssm_data.float())                dssp_var = Variable(dssp_data.float())                local_var = Variable(local_data.float())                target_var = Variable(label.float())  # 就是标签                print(target_var)        output = getnewmodel(newmodel,seq_var, dssp_var, pssm_var, local_var)        feature_batch.append(output.data.cpu().numpy())        label_batch.append(label.tolist())    feature_data = np.concatenate(feature_batch, axis=0)    label_data = np.concatenate(label_batch, axis=0)    return feature_data,label_dataif __name__ == '__main__':    path_dir = "/home/xyj/Project/DeepPPISP-master/checkpoints/deep_ppi_saved_models"    #需要修改    model_file = "{0}/DeepPPI_model_epoch1_train1.dat".format(path_dir)    train_data = ["dset186","dset164","dset72"]    class_nums = 1    window_size = 3    ratio = (2, 1)    batch_size = 32    configs = DefaultConfig()    model = DeepPPI(class_nums, window_size, ratio)    model.load_state_dict(torch.load(model_file))    newmodel = model.cuda()    train_sequences_file = ['/home/xyj/Project/DeepPPISP-master/data_cache/{0}_sequence_data.pkl'.format(key) for key in train_data]    train_dssp_file = ['/home/xyj/Project/DeepPPISP-master/data_cache/{0}_dssp_data.pkl'.format(key) for key in train_data]    train_pssm_file = ['/home/xyj/Project/DeepPPISP-master/data_cache/{0}_pssm_data.pkl'.format(key) for key in train_data]    train_label_file = ['/home/xyj/Project/DeepPPISP-master/data_cache/{0}_label.pkl'.format(key) for key in train_data]    all_list_file = '/home/xyj/Project/DeepPPISP-master/data_cache/all_dset_list.pkl'    test_list_file = '/home/xyj/Project/DeepPPISP-master/data_cache/testing_list.pkl'    #加载训练样本    with open('/home/xyj/Project/DeepPPISP-master/indexes/train_index_epoch1_train1.pkl', "rb") as ti:        train_index = pickle.load(ti)    train_samples = sampler.SubsetRandomSampler(train_index)    train_dataSet = data_generator.dataSet(window_size, train_sequences_file, train_pssm_file, train_dssp_file,                                       train_label_file,                                       all_list_file)    train_loader = torch.utils.data.DataLoader(train_dataSet, batch_size=batch_size,                                               sampler=train_samples, pin_memory=(torch.cuda.is_available()),                                               num_workers=5, drop_last=False)    train_feature, train_label = trainfunction(train_loader,newmodel)    embedding = umap.UMAP().fit_transform(train_feature, train_label)    fig = plt.figure(figsize=(10, 8))    plt.scatter(embedding[:, 0], embedding[:, 1], s=20, c=train_label, cmap='Set3', alpha=1.0)    cbar = plt.colorbar(boundaries=np.arange(3) - 0.5)    cbar.set_ticks(np.arange(2))    plt.title('Training set embedded by supervised UMAP ', fontsize=20)    plt.show()